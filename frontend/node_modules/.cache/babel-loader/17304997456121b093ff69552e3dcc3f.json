{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _immutabilityHelper = require('immutability-helper');\n\nvar _immutabilityHelper2 = _interopRequireDefault(_immutabilityHelper);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar _class = function () {\n  function _class() {\n    _classCallCheck(this, _class);\n\n    this.count = {};\n    this.instance = undefined;\n  }\n\n  _createClass(_class, [{\n    key: 'initialize',\n    value: function initialize(instance) {\n      this.instance = instance;\n    }\n  }, {\n    key: 'enableLoad',\n    value: function enableLoad(args) {\n      var _this = this;\n\n      if (this.instance && args.autoload && typeof args.autoload === 'number') {\n        this.count[args.channels] = args.autoload;\n        args.channels.forEach(function (channel) {\n          _this.count[channel] = args.autoload;\n        });\n      }\n    }\n  }, {\n    key: 'getHistory',\n    value: function getHistory(channel, callback) {\n      var _this2 = this;\n\n      if (this.count[channel]) {\n        this.instance.history({\n          channel: channel,\n          count: this.count[channel]\n        }).then(function (response) {\n          response.messages.forEach(function (m) {\n            m.message = m.entry;\n            m.channel = channel;\n\n            _this2.instance._component.setState(function (prevState) {\n              return {\n                pn_messages: (0, _immutabilityHelper2.default)(prevState.pn_messages, _defineProperty({}, channel, {\n                  $push: [m]\n                }))\n              };\n            });\n          });\n\n          if (callback) {\n            callback();\n          }\n        }).catch(function () {});\n      }\n    }\n  }, {\n    key: 'disableLoad',\n    value: function disableLoad(args) {\n      var _this3 = this;\n\n      if (Array.isArray(args.channels)) {\n        args.channels.forEach(function (ch) {\n          if (_this3.count[ch]) delete _this3.count[ch];\n        });\n      } else if (this.count[args.channels]) {\n        delete this.count[args.channels];\n      }\n    }\n  }]);\n\n  return _class;\n}();\n\nexports.default = _class;\nmodule.exports = exports['default'];","map":{"version":3,"sources":["autoload.js"],"names":["instance","args","channel","callback","count","response","m","pn_messages","prevState","$push","Array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGE,WAAA,MAAA,GAAc;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,MAAA,CAAA;;AACZ,SAAA,KAAA,GAAA,EAAA;AACA,SAAA,QAAA,GAAA,SAAA;AACD;;;;+BAOUA,Q,EAAU;AACnB,WAAA,QAAA,GAAA,QAAA;AACD;;;+BAOUC,I,EAAM;AAAA,UAAA,KAAA,GAAA,IAAA;;AACf,UAAI,KAAA,QAAA,IAAiBA,IAAAA,CAAjB,QAAA,IAAkC,OAAOA,IAAAA,CAAP,QAAA,KAAtC,QAAA,EAAyE;AACvE,aAAA,KAAA,CAAWA,IAAAA,CAAX,QAAA,IAA4BA,IAAAA,CAA5B,QAAA;AAEAA,QAAAA,IAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAAsB,UAAA,OAAA,EAAa;AACjC,UAAA,KAAA,CAAA,KAAA,CAAA,OAAA,IAAsBA,IAAAA,CAAtB,QAAA;AADFA,SAAAA;AAGD;AACF;;;+BAQUC,O,EAASC,Q,EAAU;AAAA,UAAA,MAAA,GAAA,IAAA;;AAC5B,UAAI,KAAA,KAAA,CAAJ,OAAI,CAAJ,EAAyB;AACvB,aAAA,QAAA,CAAA,OAAA,CAAsB;AAAED,UAAAA,OAAAA,EAAF,OAAA;AAAoBE,UAAAA,KAAAA,EAAO,KAAA,KAAA,CAAjD,OAAiD;AAA3B,SAAtB,EAAA,IAAA,CAA6E,UAAA,QAAA,EAAc;AACzFC,UAAAA,QAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAA0B,UAAA,CAAA,EAAO;AAC/BC,YAAAA,CAAAA,CAAAA,OAAAA,GAAYA,CAAAA,CAAZA,KAAAA;AACAA,YAAAA,CAAAA,CAAAA,OAAAA,GAAAA,OAAAA;;AAEA,YAAA,MAAA,CAAA,QAAA,CAAA,UAAA,CAAA,QAAA,CAAkC,UAAA,SAAA,EAAA;AAAA,qBAAc;AAC9CC,gBAAAA,WAAAA,EAAa,CAAA,GAAA,oBAAA,CAAA,OAAA,EAAOC,SAAAA,CAAP,WAAA,EAAA,eAAA,CAAA,EAAA,EAAA,OAAA,EAA2C;AAAEC,kBAAAA,KAAAA,EAAO,CAApD,CAAoD;AAAT,iBAA3C,CAAA;AADiC,eAAd;AAAlC,aAAA;AAJFJ,WAAAA;;AASA,cAAA,QAAA,EAAc;AACZF,YAAAA,QAAAA;AACD;AAZH,SAAA,EAAA,KAAA,CAaS,YAAM,CAbf,CAAA;AAcD;AACF;;;gCAOWF,I,EAAM;AAAA,UAAA,MAAA,GAAA,IAAA;;AAChB,UAAIS,KAAAA,CAAAA,OAAAA,CAAcT,IAAAA,CAAlB,QAAIS,CAAJ,EAAkC;AAChCT,QAAAA,IAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAAsB,UAAA,EAAA,EAAQ;AAC5B,cAAI,MAAA,CAAA,KAAA,CAAJ,EAAI,CAAJ,EAAoB,OAAO,MAAA,CAAA,KAAA,CAAP,EAAO,CAAP;AADtBA,SAAAA;AADF,OAAA,MAIO,IAAI,KAAA,KAAA,CAAWA,IAAAA,CAAf,QAAI,CAAJ,EAA+B;AACpC,eAAO,KAAA,KAAA,CAAWA,IAAAA,CAAlB,QAAO,CAAP;AACD;AACF","sourcesContent":["import update from 'immutability-helper';\n\nexport default class {\n  constructor() {\n    this.count = {};\n    this.instance = undefined;\n  }\n\n  /**\n   * Initialize the autoload with a wrapper instance\n   *\n   * @param instance\n   */\n  initialize(instance) {\n    this.instance = instance;\n  }\n\n  /**\n   * Enable the autoload for a channel or a set of channels subscribed\n   *\n   * @param args\n   */\n  enableLoad(args) {\n    if (this.instance && args.autoload && typeof args.autoload === 'number') {\n      this.count[args.channels] = args.autoload;\n\n      args.channels.forEach((channel) => {\n        this.count[channel] = args.autoload;\n      });\n    }\n  }\n\n  /**\n   * Get history of a channel or a set of channels.\n   *\n   * @param {string|[string]} channel\n   * @param callback\n   */\n  getHistory(channel, callback) {\n    if (this.count[channel]) {\n      this.instance.history({ channel: channel, count: this.count[channel] }).then((response) => {\n        response.messages.forEach((m) => {\n          m.message = m.entry;\n          m.channel = channel;\n\n          this.instance._component.setState(prevState => ({\n            pn_messages: update(prevState.pn_messages, { [channel]: { $push: [m] } })\n          }));\n        });\n\n        if (callback) {\n          callback();\n        }\n      }).catch(() => {});\n    }\n  }\n\n  /**\n   * Disable the autoload for a channel or set of channels\n   *\n   * @param args\n   */\n  disableLoad(args) {\n    if (Array.isArray(args.channels)) {\n      args.channels.forEach((ch) => {\n        if (this.count[ch]) delete this.count[ch];\n      });\n    } else if (this.count[args.channels]) {\n      delete this.count[args.channels];\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}